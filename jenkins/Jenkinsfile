// Progress reporter (used inside script blocks)
// Progress reporter (used inside script blocks)
def reportProgress = { stageName, status, message, percent ->
    // paramsì™€ envë¥¼ ëª¨ë‘ í™•ì¸ (Auto-Scan Setupì—ì„œ ì„¤ì •ëœ envê°€ ìš°ì„ )
    def scanId = env.SCAN_ID ?: params.SCAN_ID
    def projectId = env.PROJECT_ID ?: params.PROJECT_ID
    def apiBase = env.API_BASE ?: params.API_BASE

    // Scan IDê°€ 0ì´ê±°ë‚˜ ì—†ìœ¼ë©´ ë°±ì—”ë“œì— ë³´ê³ í•  ìˆ˜ ì—†ìŒ (ì•„ì§ ìƒì„±ë˜ì§€ ì•ŠìŒ)
    if (!scanId || scanId == '0' || scanId == 0) {
        echo "[RepoProgress] Skip backend report (Invalid ScanID: ${scanId}). Message: ${message}"
        return
    }

    def percentLine = percent != null ? "\"progress_percent\": ${percent}" : "\"progress_percent\": null"
    def payload = """{
  "stage": "${stageName}",
  "status": "${status}",
  "message": "${message}",
  ${percentLine}
}"""
    def cmd = """
        cat > progress_payload.json <<'EOF'
${payload}
EOF
        curl -sS -X PATCH "${apiBase}/projects/${projectId}/scans/${scanId}/progress" \\
            -H "Content-Type: application/json" \\
            -H "X-Api-Key: ${env.BACKEND_SERVICE_API_KEY}" \\
            -H "X-Jenkins-Token: ${env.JENKINS_CALLBACK_SECRET}" \\
            --data @progress_payload.json || true
    """
    try {
        sh label: "report-progress-${stageName}", script: cmd
    } catch (ignored) {
        // ë¬´ì‹œ
    }
}

// Email notifier (runs only when NOTIFY_EMAILS is provided)
// Email notifier (runs only when NOTIFY_EMAILS is provided)
def sendEmailNotification = { statusText, extraMessage = "" ->
    def recipients = env.NOTIFY_EMAILS ?: params.NOTIFY_EMAILS
    if (recipients) recipients = recipients.trim()
    
    if (!recipients) {
        return
    }
    def projectLabel = env.PROJECT_NAME ?: params.PROJECT_NAME ?: params.GITHUB_URL ?: "project"
    def scanId = env.SCAN_ID ?: params.SCAN_ID
    
    def subject = "[L2VE] Scan ${projectLabel} #${BUILD_NUMBER} ${statusText}"
    def body = """<table width="100%" cellpadding="0" cellspacing="0" style="background-color:#f5f7fa; padding:24px;">
  <tbody><tr><td align="center">
      <table width="600" cellpadding="0" cellspacing="0" style="background-color:#ffffff; border-radius:8px; overflow:hidden;">

        
        <tbody><tr><td style="background-color:#0f172a; padding:20px 24px;                     font-family:-apple-system,BlinkMacSystemFont,'Apple SD Gothic Neo',                     'Noto Sans KR','Malgun Gothic',Arial,sans-serif;">
            <span style="font-size:18px; color:#ffffff; font-weight:600;">
              ğŸ” L2VE ìŠ¤ìº” ì™„ë£Œ ì•Œë¦¼
            </span>
          </td></tr>

        
        <tr><td style="padding:24px;                     font-family:-apple-system,BlinkMacSystemFont,'Apple SD Gothic Neo',                     'Noto Sans KR','Malgun Gothic',Arial,sans-serif;                     color:#1f2937;">
            <p style="margin:0 0 16px 0; font-size:14px; line-height:1.6;">
              ì•ˆë…•í•˜ì„¸ìš”,
            </p>

            <p style="margin:0 0 20px 0; font-size:14px; line-height:1.6;">
              L2VE ë³´ì•ˆ ìŠ¤ìº”ì´ <strong>ì™„ë£Œ</strong>ë˜ì—ˆìŠµë‹ˆë‹¤.<br>
              ìì„¸í•œ ì •ë³´ëŠ” ì•„ë˜ë¥¼ í™•ì¸í•´ ì£¼ì„¸ìš”.
            </p>

            
            <table width="100%" cellpadding="0" cellspacing="0" style="background-color:#f9fafb; border:1px solid #e5e7eb; border-radius:6px;">
              <tbody><tr><td style="padding:16px;">
                  <p style="margin:0 0 12px 0; font-size:14px; font-weight:600;">
                    ğŸ“Œ ìŠ¤ìº” ê²°ê³¼
                  </p>

                  <table width="100%" cellpadding="0" cellspacing="0" style="font-size:13px; color:#374151;">
                    <tbody><tr><td style="padding:6px 0; width:120px;">í”„ë¡œì íŠ¸</td><td style="padding:6px 0;">${projectLabel}</td></tr>
                    <tr><td style="padding:6px 0;">ìŠ¤ìº” ID</td><td style="padding:6px 0;">${scanId}</td></tr>
                    <tr><td style="padding:6px 0;">ìƒíƒœ</td><td style="padding:6px 0; font-weight:700; color:#16a34a;">
${statusText}
                      </td></tr>
                    <tr><td style="padding:6px 0;">ë¹Œë“œ ë²ˆí˜¸</td><td style="padding:6px 0;">#${BUILD_NUMBER}</td></tr>
                  </tbody></table>
                </td></tr>
            </tbody></table>

            <p style="margin:20px 0 0 0; font-size:12px; color:#6b7280;">
              ë³¸ ë©”ì¼ì€ L2VE í”Œë«í¼ì— ì˜í•´ ìë™ìœ¼ë¡œ ë°œì†¡ë˜ì—ˆìŠµë‹ˆë‹¤.
            </p>
          </td></tr>

        
        <tr><td style="background-color:#f3f4f6; padding:12px 24px;                     font-family:-apple-system,BlinkMacSystemFont,'Apple SD Gothic Neo',                     'Noto Sans KR','Malgun Gothic',Arial,sans-serif;                     font-size:12px; color:#6b7280;">
            L2VE: LLM to Vulnerabilities &amp; Exploits
          </td></tr>

      </tbody></table>
    </td></tr>
</tbody></table>"""

    try {
        emailext(
            to: recipients,
            subject: subject,
            body: body,
            mimeType: 'text/html; charset=UTF-8',
        )
    } catch (ignored) {
        echo "âš  ì´ë©”ì¼ ë°œì†¡ì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤: ${ignored}"
    }
}

pipeline {
    agent any

    options {
        buildDiscarder(logRotator(numToKeepStr: '10', artifactNumToKeepStr: '10'))
        timeout(time: 24, unit: 'HOURS')
        disableConcurrentBuilds()
    }

    parameters {
        choice(name: 'SOURCE_TYPE', choices: ['git', 'upload'], description: 'git=Git Repository, upload=ZIP File Upload')
        string(name: 'GITHUB_URL', defaultValue: '', description: 'GitHub ì €ì¥ì†Œ URL (SOURCE_TYPE=gitì¼ ë•Œ ì‚¬ìš©)')
        string(name: 'UPLOADED_FILE_PATH', defaultValue: '', description: 'ì—…ë¡œë“œëœ ZIP íŒŒì¼ ê²½ë¡œ (SOURCE_TYPE=uploadì¼ ë•Œ ì‚¬ìš©)')
        string(name: 'PROJECT_NAME', defaultValue: '', description: 'í”„ë¡œì íŠ¸ ì´ë¦„')
        choice(name: 'SCAN_TYPE', choices: ['ALL', 'SSRF', 'RCE', 'XSS', 'SQLi', 'IDOR', 'PATH_TRAVERSAL', 'AUTH'], description: 'ìŠ¤ìº” íƒ€ì…')
        // ììœ  ì…ë ¥ìœ¼ë¡œ ë°›ì•„ ë‹¤ì–‘í•œ LLM ì œê³µìë¥¼ ì§€ì› (ì˜ˆ: groq, openai, azure-openai ë“±)
        string(name: 'API_PROVIDER', defaultValue: 'groq', description: 'LLM API ì œê³µì (ì˜ˆ: groq, openai, azure-openai ë“±)')
        string(name: 'MODEL', defaultValue: 'gpt-4o', description: 'LLM ëª¨ë¸ (ì˜ˆ: qwen/qwen3-32b, llama-3.3-70b-versatile, gpt-4o ë“±)')
        booleanParam(name: 'RUN_SAST', defaultValue: true, description: 'Semgrep SAST ì‹¤í–‰ ì—¬ë¶€')
        choice(name: 'SCAN_MODE', choices: ['custom', 'preset'], description: 'custom=Full Scan, preset=Quick Scan')
        choice(name: 'PROFILE_MODE', choices: ['preset', 'custom'], description: 'preset=ê¸°ë³¸ ì„¤ì •, custom=ê³ ê¸‰ ì„¤ì •')
        string(name: 'PROJECT_ID', defaultValue: '1', description: 'L2VE ë°±ì—”ë“œ project_id')
        string(name: 'SCAN_ID', defaultValue: '0', description: 'L2VE ë°±ì—”ë“œ scan_id')
        choice(name: 'TRIGGER_MODE', choices: ['web', 'git'], description: 'web=ì›¹ UI ìˆ˜ë™ ìŠ¤ìº”, git=Git webhook ìë™ ìŠ¤ìº”')
        string(name: 'API_BASE', defaultValue: 'http://backend:3000/api', description: 'L2VE ë°±ì—”ë“œ API Base')
        string(name: 'BACKEND_SERVICE_API_KEY', defaultValue: '', description: 'ë°±ì—”ë“œ ê³ ì • API Key')
        string(name: 'JENKINS_CALLBACK_SECRET', defaultValue: '', description: 'ë°±ì—”ë“œ ì½œë°± ì‹œí¬ë¦¿')
        string(name: 'LLM_ENDPOINT_URL', defaultValue: '', description: 'ì˜µì…˜: ì»¤ìŠ¤í…€ LLM ì—”ë“œí¬ì¸íŠ¸ URL')
        string(name: 'LLM_API_KEY', defaultValue: '', description: 'ì˜µì…˜: ì»¤ìŠ¤í…€ LLM API Key/Token')
        string(name: 'SEED_FILE_PATH', defaultValue: '', description: 'SARIF/Diet seed file path for verifier (quick mode)')
        string(name: 'AWS_BEDROCK_RPM',defaultValue: '30', description: 'AWS Bedrock ìš”ì²­ ì œí•œ (ë¶„ë‹¹ ìš”ì²­ ìˆ˜, ê¸°ë³¸ 30)')
        string(name: 'AWS_BEDROCK_TPM',defaultValue: '10000', description: 'AWS Bedrock ë¶„ë‹¹ í† í° ì œí•œ (ê¸°ë³¸ 10,000)')
        string(name: 'NOTIFY_EMAILS', defaultValue: '', description: 'ìŠ¤ìº” ì™„ë£Œ/ì‹¤íŒ¨ ì•Œë¦¼ ìˆ˜ì‹ ì (ì½¤ë§ˆ êµ¬ë¶„)')
    }

    environment {
        SCANNER_DIR = '/var/jenkins_home/langgraph-scanner'
        QUICK_SCAN_DIR = '/var/jenkins_home/langgraph-scan'
        PROJECTS_DIR = '/var/jenkins_home/projects'
        GROQ_API_KEY = credentials('groq-api-key')
        OPENAI_API_KEY = credentials('openai-api-key')
        LANGCHAIN_API_KEY = credentials('langsmith-api-key')
        OPENROUTER_API_KEY = credentials('openrouter-api-key')
        GITHUB_TOKEN = credentials('github-token')
        AWS_BEARER_TOKEN_BEDROCK = credentials('bedrock-api-key')
        BEDROCK_AWS_REGION = credentials('bedrock-aws-region')
        OPENAI_COMPATIBLE_BASE_URL = "${params.LLM_ENDPOINT_URL ?: ''}"
        OPENAI_COMPATIBLE_API_KEY  = "${params.LLM_API_KEY   ?: ''}"
        AWS_BEDROCK_RPM = "${params.AWS_BEDROCK_RPM ?: '60'}"
        AWS_BEDROCK_TPM = "${params.AWS_BEDROCK_TPM ?: '60000'}"
        BACKEND_SERVICE_API_KEY = credentials('backend-api-key')
        JENKINS_CALLBACK_SECRET = credentials('jenkins-callback-secret')
    }

    stages {
        stage('Auto-Scan Setup') {
            // Gitìœ¼ë¡œ íŠ¸ë¦¬ê±°ë˜ì—ˆê±°ë‚˜ SCAN_IDê°€ 0ì¸ ê²½ìš°ì—ë§Œ ì‹¤í–‰
            when {
                expression { env.TRIGGER_MODE == 'git' || params.TRIGGER_MODE == 'git' || params.SCAN_ID == '0' }
            }
            steps {
                script {
                    echo "========"
                    echo "= Auto-Scan Setup (Git Trigger Detected)"
                    echo "========"

                    // 1. Git URL í™•ì¸ (GWT ë³€ìˆ˜ ìš°ì„ )
                    def gitUrl = env.GW_REPO_URL ?: params.GITHUB_URL ?: env.GitUrl
                    if (!gitUrl && env.GIT_URL) {
                        gitUrl = env.GIT_URL
                    }
                    if (!gitUrl) {
                        // SCMì—ì„œ ì¶”ì¶œ ì‹œë„
                        try {
                            gitUrl = sh(script: 'git config --get remote.origin.url', returnStdout: true).trim()
                        } catch (e) {
                            echo "WARN: Failed to get git url from git config: ${e}"
                        }
                    }

                    echo "Detected GIT_URL: ${gitUrl}"
                    echo "Detected GITHUB_COMMIT_HASH: ${env.GW_COMMIT}"

                    if (!gitUrl) {
                        error "Git URLì„ ì°¾ì„ ìˆ˜ ì—†ì–´ ìë™ ìŠ¤ìº”ì„ ì„¤ì •í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤."
                    }

                    // 2. ë°±ì—”ë“œ API í˜¸ì¶œí•˜ì—¬ ìŠ¤ìº” ìƒì„± ë° ì„¤ì • ê°€ì ¸ì˜¤ê¸°
                    def apiBase = params.API_BASE ?: "http://backend:3000/api"
                    
                    echo "Calling Backend API to setup scan (Endpoint: ${apiBase}/projects/auto-scan/git)..."
                    
                    // JSON payload construction with proper escaping
                    def payload = """{
                        "github_url": "${gitUrl}",
                        "github_commit_hash": "${env.GW_COMMIT ?: ''}",
                        "scan_type": "ALL",
                        "scan_mode": "standard",
                        "profile_mode": "comprehensive",
                        "source_type": "git"
                    }"""
                    
                    // Write payload to file to avoid quoting issues
                    writeFile file: 'auto_scan_req.json', text: payload
                    
                    def response = sh(script: """
                        curl -sS -X POST "${apiBase}/projects/auto-scan/git" \\
                            -H "Content-Type: application/json" \\
                            -H "X-Api-Key: ${env.BACKEND_SERVICE_API_KEY}" \\
                            --data @auto_scan_req.json
                    """, returnStdout: true).trim()

                    echo "Backend Response: ${response}"

                    // 3. ì‘ë‹µ íŒŒì‹± ë° í™˜ê²½ë³€ìˆ˜ ì„¤ì •
                    def props = readJSON text: response

                    if (!props.id) {
                         error "Failed to create auto-scan. Response does not contain scan ID."
                    }

                    // í™˜ê²½ ë³€ìˆ˜ ì„¤ì • (Stringìœ¼ë¡œ ë³€í™˜)
                    env.SCAN_ID = "${props.id}"
                    env.PROJECT_ID = "${props.project_id}"
                    // Project nameì€ ì‘ë‹µì— ì—†ìœ¼ë‚˜ GWTì—ì„œ ì˜¬ ìˆ˜ ìˆìŒ. ì—†ìœ¼ë©´ URLì—ì„œ íŒŒì‹±
                    env.PROJECT_NAME = env.GW_PROJECT_NAME ?: gitUrl.tokenize('/')[-1].replace('.git', '')
                    env.SCAN_MODE = props.scan_mode
                    env.PROFILE_MODE = props.profile_mode
                    env.TRIGGER_MODE = 'git'
                    // Backend created response should now include these
                    env.API_PROVIDER = props.api_provider
                    env.MODEL = props.model
                    env.SCAN_TYPE = 'ALL' 
                    
                    echo "âœ“ Auto-Scan Configured:"
                    echo "  - SCAN_ID: ${env.SCAN_ID}"
                    echo "  - PROJECT_ID: ${env.PROJECT_ID}"
                    echo "  - PROJECT_NAME: ${env.PROJECT_NAME}"
                    echo "  - SCAN_MODE: ${env.SCAN_MODE}" 

                    // ì´ì œ SCAN_IDê°€ ìƒê²¼ìœ¼ë¯€ë¡œ setup ë‹¨ê³„ ë³´ê³ 
                    reportProgress("setup", "running", "ìë™ ìŠ¤ìº” ì„¤ì • ì™„ë£Œ (ID: ${env.SCAN_ID})", 5)
                }
            }
        }

        stage('Validate Input') {
            steps {
                script {
                    // í™˜ê²½ë³€ìˆ˜ê°€ ì„¤ì •ë˜ì–´ ìˆìœ¼ë©´ ê·¸ê²ƒì„ ì‚¬ìš©, ì•„ë‹ˆë©´ íŒŒë¼ë¯¸í„° ì‚¬ìš©
                    if (!env.SCAN_ID) env.SCAN_ID = params.SCAN_ID
                    if (!env.PROJECT_ID) env.PROJECT_ID = params.PROJECT_ID
                    if (!env.SCAN_MODE) env.SCAN_MODE = params.SCAN_MODE
                    if (!env.SCAN_TYPE) env.SCAN_TYPE = params.SCAN_TYPE
                    if (!env.PROFILE_MODE) env.PROFILE_MODE = params.PROFILE_MODE
                    if (!env.TRIGGER_MODE) env.TRIGGER_MODE = params.TRIGGER_MODE
                    if (!env.NOTIFY_EMAILS) env.NOTIFY_EMAILS = params.NOTIFY_EMAILS
                    
                    reportProgress("setup", "running", "ì…ë ¥ ê²€ì¦", 5)
                    echo "ë¹Œë“œ ë²ˆí˜¸: ${BUILD_NUMBER}"
                    echo "ìŠ¤ìº” ëª¨ë“œ: ${env.SCAN_MODE} (${env.SCAN_MODE == 'custom' ? 'Full Scan (langgraph-scanner)' : 'Quick Scan (langgraph-scan)'})"
                    echo "ìŠ¤ìº” íƒ€ì…: ${env.SCAN_TYPE}"

                    // í”„ë¡œì íŠ¸ ì´ë¦„ ì„¤ì • (ì´ë¯¸ Auto-Scan Setupì—ì„œ ì„¤ì •ë˜ì—ˆì„ ìˆ˜ ìˆìŒ)
                    if (!env.PROJECT_NAME) {
                        if (params.SOURCE_TYPE == 'git' && params.GITHUB_URL) {
                            env.PROJECT_NAME = params.GITHUB_URL.tokenize('/')[-1].replace('.git', '')
                        } else if (params.PROJECT_NAME) {
                            env.PROJECT_NAME = params.PROJECT_NAME
                        } else {
                            error("í”„ë¡œì íŠ¸ ì´ë¦„ì„ í™•ì¸í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤.")
                        }
                    }

                    env.PROJECT_PATH = "${PROJECTS_DIR}/${env.PROJECT_NAME}"
                    echo "í”„ë¡œì íŠ¸: ${env.PROJECT_NAME}"
                    echo "í”„ë¡œì íŠ¸ ê²½ë¡œ: ${env.PROJECT_PATH}"
                    reportProgress("setup", "completed", "ì…ë ¥ ê²€ì¦ ì™„ë£Œ", 10)
                }
            }
        }

        stage('Setup Scanner Environment') {
            steps {
                script {
                    reportProgress("setup", "running", "ìŠ¤ìºë„ˆ í™˜ê²½ ì„¤ì •", 20)
                    // Full Scanìš© langgraph-scanner ì„¤ì •
                    sh '''
                        set -e
                        apt-get update
                        apt-get install -y vim
                        if ! command -v node >/dev/null 2>&1; then
                            apt-get update && apt-get install -y nodejs npm
                        fi
                        node -v || true
                        cd $SCANNER_DIR
                        if [ ! -d venv ]; then
                            python3 -m venv venv
                        fi
                        . venv/bin/activate
                        pip install -r requirements.txt --quiet
                        
                        # .env íŒŒì¼ ìƒì„±
                        cat > .env << EOF
GROQ_API_KEY=${GROQ_API_KEY}
OPENAI_API_KEY=${OPENAI_API_KEY}
LANGCHAIN_API_KEY=${LANGCHAIN_API_KEY}
OPENROUTER_API_KEY=${OPENROUTER_API_KEY}
MCP_SERVER_URL=http://localhost:9121/mcp
LANGCHAIN_TRACING_V2=true
LANGCHAIN_ENDPOINT=https://api.smith.langchain.com
AWS_BEARER_TOKEN_BEDROCK=${AWS_BEARER_TOKEN_BEDROCK}
BEDROCK_AWS_REGION=${BEDROCK_AWS_REGION}
AWS_BEDROCK_RPM=${AWS_BEDROCK_RPM}
AWS_BEDROCK_TPM=${AWS_BEDROCK_TPM}
MAX_FAILED_RETRIES=3  # ì‹¤íŒ¨í•œ ë°°ì¹˜ ì¬ì‹œë„ ì•ˆ í•¨

OPENAI_RPM=100000
OPENAI_TPM=100000000

# Agent Configuration for OpenRouter (qwen3-235b-a22b-2507)
AGENT_RECURSION_LIMIT=500    # ê·¸ë˜í”„ ìµœëŒ€ ë°˜ë³µ íšŸìˆ˜
AGENT_MAX_TOOL_CALLS=50      # ë°°ì¹˜ë‹¹ ìµœëŒ€ ë„êµ¬ í˜¸ì¶œ íšŸìˆ˜

DISCOVERY_TOOL_ONLY_RETRY_LIMIT=50  # ë„êµ¬ ì „ìš© ì‹œë„ ìµœëŒ€ íšŸìˆ˜

MAX_CHUNK_SIZE=3000  # Maximum JSON string length per chunk (reduced for large prompts)
MAX_ANSWER_CHARS=50000  # MCP tool max answer chars


# # Agent Configuration for llama-server (qwen3-30b-a3b-thinking-2507)
# AGENT_RECURSION_LIMIT=500    # ê·¸ë˜í”„ ìµœëŒ€ ë°˜ë³µ íšŸìˆ˜
# AGENT_MAX_TOOL_CALLS=20      # ë°°ì¹˜ë‹¹ ìµœëŒ€ ë„êµ¬ í˜¸ì¶œ íšŸìˆ˜

# DISCOVERY_TOOL_ONLY_RETRY_LIMIT=20  # ë„êµ¬ ì „ìš© ì‹œë„ ìµœëŒ€ íšŸìˆ˜

# MAX_CHUNK_SIZE=500  # Maximum JSON string length per chunk (reduced for large prompts)
# MAX_ANSWER_CHARS=100000  # MCP tool max answer chars

DISCOVERY_MAX_WORKERS=4  # Discovery agent ë³‘ë ¬ ì‘ì—…ì ìˆ˜

# Default number of analysis workers per vulnerability type (min 1)
ANALYSIS_WORKERS_DEFAULT=1

# íŠ¹ì • ìœ í˜•ë§Œ ë³‘ë ¬ì²˜ë¦¬ ì‘ì—…ì ìˆ˜ ì„¤ì •
# Override worker counts per type: format LABEL=count, comma-separated (e.g., XSS=2,SSRF=3)
# ANALYSIS_WORKER_OVERRIDES=""

# Max retries per worker when analysis fails (0 means no retry)
ANALYSIS_WORKER_MAX_RETRIES=0


# ANALYSIS_MAX_CONCURRENT_AGENTS=2  # ë¶„ì„ ì—ì´ì „íŠ¸ ë™ì‹œ ì‹¤í–‰ ìˆ˜ ì œí•œ
# DISCOVERY_MAX_WORKERS=2  # Discovery agent ë³‘ë ¬ ì‘ì—…ì ìˆ˜
EOF
                        
                        # results ë””ë ‰í† ë¦¬ ìƒì„±
                        mkdir -p analysis_results
                    '''

                    // Quick Scanìš© langgraph-scan ì„¤ì • (SCAN_MODEê°€ presetì¼ ë•Œë§Œ)
                    if (env.SCAN_MODE == 'preset' || env.SCAN_MODE == 'custom') {
                        sh '''
                            set -e
                            cd $QUICK_SCAN_DIR
                            if [ ! -d venv ]; then
                                python3 -m venv venv
                            fi
                            . venv/bin/activate
                            pip install -r requirements.txt --quiet

                            # .env íŒŒì¼ ìƒì„±
                            cat > .env << EOF
GROQ_API_KEY=${GROQ_API_KEY}
OPENAI_API_KEY=${OPENAI_API_KEY}
LANGCHAIN_API_KEY=${LANGCHAIN_API_KEY}
OPENROUTER_API_KEY=${OPENROUTER_API_KEY}
MCP_SERVER_URL=http://localhost:8000/mcp
LANGCHAIN_TRACING_V2=true
LANGCHAIN_ENDPOINT=https://api.smith.langchain.com
AWS_BEARER_TOKEN_BEDROCK=${AWS_BEARER_TOKEN_BEDROCK}
BEDROCK_AWS_REGION=${BEDROCK_AWS_REGION}
AWS_BEDROCK_RPM=${AWS_BEDROCK_RPM}
AWS_BEDROCK_TPM=${AWS_BEDROCK_TPM}
EOF
                            
                            # results ë””ë ‰í† ë¦¬ ìƒì„±
                            mkdir -p results
                        '''
                    }
                    reportProgress("setup", "completed", "ìŠ¤ìºë„ˆ í™˜ê²½ ì„¤ì • ì™„ë£Œ", 30)
                }
            }
        }

        stage('Clone Target Project') {
            when {
                expression { params.SOURCE_TYPE == 'git' }
            }
            steps {
                script {
                    reportProgress("checkout", "running", "Git ë¦¬í¬ì§€í† ë¦¬ í´ë¡ ", 40)
                    sh """
                        set -e
                        rm -rf ${PROJECT_PATH}
                        mkdir -p ${PROJECTS_DIR}
                        cd ${PROJECTS_DIR}
                        
                        if [ -n "${GITHUB_TOKEN}" ]; then
                            git clone https://${GITHUB_TOKEN}@\$(echo ${params.GITHUB_URL} | sed 's|https://||') ${PROJECT_NAME}
                        else
                            git clone ${params.GITHUB_URL} ${PROJECT_NAME}
                        fi
                        
                        echo "âœ“ í”„ë¡œì íŠ¸ í´ë¡  ì™„ë£Œ: ${PROJECT_PATH}"
                    """
                    reportProgress("checkout", "completed", "Git ë¦¬í¬ì§€í† ë¦¬ í´ë¡  ì™„ë£Œ", 45)
                }
            }
        }

        stage('Extract Uploaded File') {
            when {
                expression { params.SOURCE_TYPE == 'upload' }
            }
            steps {
                script {
                    reportProgress("checkout", "running", "ZIP ì••ì¶• í•´ì œ", 40)
                    sh """
                        set -e
                        rm -rf ${PROJECT_PATH}
                        mkdir -p ${PROJECT_PATH}
                        unzip -q ${params.UPLOADED_FILE_PATH} -d ${PROJECT_PATH}
                        # ë§Œì•½ ì••ì¶• í•´ì œëœ ë””ë ‰í† ë¦¬ì— ë‹¨ í•˜ë‚˜ì˜ í•˜ìœ„ ë””ë ‰í† ë¦¬ë§Œ ì¡´ì¬í•œë‹¤ë©´, ê·¸ í•˜ìœ„ ë””ë ‰í† ë¦¬ì˜ ë‚´ìš©ë¬¼ì„ ìƒìœ„ ë””ë ‰í† ë¦¬ë¡œ ì´ë™ì‹œí‚¤ê³  í•˜ìœ„ ë””ë ‰í† ë¦¬ë¥¼ ì‚­ì œí•©ë‹ˆë‹¤.
                        if [ \$(ls -1 ${PROJECT_PATH} | wc -l) -eq 1 ]; then
                            inner_dir=\$(ls -1 ${PROJECT_PATH})
                            if [ -d "${PROJECT_PATH}/\${inner_dir}" ]; then
                                mv ${PROJECT_PATH}/\${inner_dir}/* ${PROJECT_PATH}/
                                rm -rf ${PROJECT_PATH}/\${inner_dir}
                            fi
                        fi
                        echo "âœ“ ZIP íŒŒì¼ ì••ì¶• í•´ì œ ì™„ë£Œ: ${PROJECT_PATH}"
                    """
                    reportProgress("checkout", "completed", "ZIP ì••ì¶• í•´ì œ ì™„ë£Œ", 45)
                }
            }
        }

            stage('Detect Project Language & Env (Quick)') {
            when {
                allOf {
                    expression { env.SCAN_MODE == 'preset' || env.SCAN_MODE == 'custom' }
                }
            }
            steps {
                script {
                    echo "========"
                    echo "= Detect Project Language"
                    echo "========"
                    def detectProjectLang = {
                        if (fileExists("${PROJECT_PATH}/build.gradle.kts") || fileExists("${PROJECT_PATH}/settings.gradle.kts")) return "kotlin"
                        if (fileExists("${PROJECT_PATH}/build.gradle") || fileExists("${PROJECT_PATH}/settings.gradle") || fileExists("${PROJECT_PATH}/pom.xml")) return "java"
                        if (fileExists("${PROJECT_PATH}/package.json") || fileExists("${PROJECT_PATH}/pnpm-lock.yaml") || fileExists("${PROJECT_PATH}/yarn.lock") || fileExists("${PROJECT_PATH}/bun.lockb")) return "javascript"
                        if (fileExists("${PROJECT_PATH}/pyproject.toml") || fileExists("${PROJECT_PATH}/requirements.txt") || fileExists("${PROJECT_PATH}/Pipfile")) return "python"
                        def count = [:]
                        count["kotlin"] = sh(script: "find ${PROJECT_PATH} \\( -name '*.kt' -o -name '*.kts' \\) | wc -l", returnStdout: true).trim().toInteger()
                        count["java"] = sh(script: "find ${PROJECT_PATH} -name '*.java' | wc -l", returnStdout: true).trim().toInteger()
                        count["javascript"] = sh(script: "find ${PROJECT_PATH} \\( -name '*.ts' -o -name '*.tsx' -o -name '*.js' -o -name '*.jsx' -o -name '*.mjs' -o -name '*.cjs' -o -name '*.vue' -o -name '*.svelte' \\) | wc -l", returnStdout: true).trim().toInteger()
                        count["python"] = sh(script: "find ${PROJECT_PATH} -name '*.py' | wc -l", returnStdout: true).trim().toInteger()
                        def lang = null
                        def maxVal = -1
                        count.each { k, v ->
                            if (v > maxVal) {
                                maxVal = v
                                lang = k
                            }
                        }
                        if (!lang || maxVal == 0) {
                            error "Project Language not detected"
                        }

                        return lang
                    }

                    def langDetected = detectProjectLang()
                    env.PROJECT_LANG = langDetected
                    echo "Detected PROJECT_LANG=${env.PROJECT_LANG}"

                    if (env.PROJECT_LANG == "javascript") {
                        echo "Checking Node.js for JS/TS..."
                        sh """
                            set -e
                            if ! command -v node >/dev/null 2>&1; then
                                apt-get update && apt-get install -y nodejs npm
                            fi
                            node -v || true
                        """
                    }
                    if (env.PROJECT_LANG == "java" || env.PROJECT_LANG == "kotlin") {
                        echo "Checking maven for java/kotlin..."
                        sh """
                            set -e
                            if ! command -v mvn >/dev/null 2>&1; then
                                apt-get update && apt-get install -y maven 
                            fi
                            mvn -v || true
                        """                       
                    }                    

                    echo "========"
                    echo "= Detect Project Language DONE"
                    echo "========"

                    reportProgress("codeql", "completed", "í”„ë¡œì íŠ¸ ì–¸ì–´ ê°ì§€ ì™„ë£Œ", 50)   
                }
            }
        }

        stage('Select Codeql SUITE (Quick)') {
            when {
                allOf {
                    expression { env.SCAN_MODE == 'preset' || env.SCAN_MODE == 'custom' }
                }
            }
            steps {
                script {
                    reportProgress("codeql", "running", "CodeQL ë²ˆë“¤ ì„ íƒ", 50)
                    echo "========"
                    echo "= Select Codeql Suite"
                    echo "========"                    
                    def suiteMap = [
                        "kotlin":      "codeql/java-queries:codeql-suites/java-security-extended.qls",
                        "java":        "codeql/java-queries:codeql-suites/java-security-extended.qls",
                        "javascript":  "codeql/javascript-queries:codeql-suites/javascript-security-extended.qls",
                        "python":      "codeql/python-queries:codeql-suites/python-security-extended.qls"
                    ]

                    env.CODEQL_SUITE = suiteMap[env.PROJECT_LANG] ?: "codeql/${env.PROJECT_LANG}-security-and-quality"
                    echo "Detected SUITE=${env.CODEQL_SUITE}"


                    echo "========"
                    echo "= Select Codeql Suite DONE"
                    echo "========"

                    reportProgress("codeql", "completed", "CodeQL ë²ˆë“¤ ì„ íƒ ì™„ë£Œ", 55)
                }
            }
        }

        stage('CodeQL Analyze (Quick)') {
            when {
                allOf {
                    expression { env.SCAN_MODE == 'preset' || env.SCAN_MODE == 'custom'}
                }
            }
            steps {
                script {
                    reportProgress("codeql", "running", "CodeQL ë²ˆë“¤ ì¤€ë¹„ ë° SARIF ìƒì„±", 60)
                    def PROJECT_LANG = env.PROJECT_LANG
                    def CODEQL_SUITE = env.CODEQL_SUITE
                    echo "========"
                    echo "= CodeQL Analyze (Quick)"
                    echo "= lang=${PROJECT_LANG}, suite=${CODEQL_SUITE}"
                    echo "========"

                    def CODEQL_ROOT = "/var/jenkins_home/tools/codeql"
                    def CODEQL_BIN = "${CODEQL_ROOT}/codeql"
                    def CODEQL_BUNDLE_URL = "https://github.com/github/codeql-action/releases/download/codeql-bundle-v2.18.2/codeql-bundle-linux64.tar.gz"
                    def DB_DIR = "/var/jenkins_home/tools/codeql-db-${PROJECT_NAME}"
                    def SEED_DIR = "${QUICK_SCAN_DIR}/seed/${PROJECT_NAME}"
                    def SARIF_PATH = "${SEED_DIR}/codeql-results.sarif"
                    sh """
                        set -e
                        mkdir -p "${CODEQL_ROOT}"
                        if [ ! -x "${CODEQL_BIN}" ]; then
                            echo "Downloading CodeQL bundle..."
                            curl -sSL "${CODEQL_BUNDLE_URL}" -o /tmp/codeql-bundle.tgz
                            tar -xzf /tmp/codeql-bundle.tgz -C "${CODEQL_ROOT}" --strip-components=1
                            rm /tmp/codeql-bundle.tgz
                        fi

                        rm -rf "${DB_DIR}"
                        """
                        if (env.PROJECT_LANG == "javascript" || env.PROJECT_LANG == "python") {
                            sh """
                                "${CODEQL_BIN}" database create "${DB_DIR}" --language=${PROJECT_LANG} --source-root "${PROJECT_PATH}"
                                """
                        }
                        else if (env.PROJECT_LANG == "java" || env.PROJECT_LANG == "kotlin") {
                            sh  """
                                "${CODEQL_BIN}" database create "${DB_DIR}" --language=java --source-root "${PROJECT_PATH}" --build-mode=none
                                """
                        }
                        sh """
                        mkdir -p "${SEED_DIR}"

                        "${CODEQL_BIN}" database analyze "${DB_DIR}" ${CODEQL_SUITE} --format=sarifv2.1.0 --sarif-add-snippets --output "${SARIF_PATH}" --download

                        cd $QUICK_SCAN_DIR
                        . venv/bin/activate

                        python3 "${QUICK_SCAN_DIR}/diet.py" --input "${SARIF_PATH}" --output "${SEED_DIR}/codeql-results-diet.json"
                    """
                    env.SEED_FILE_PATH = "${SEED_DIR}/codeql-results-diet.json"
                    reportProgress("codeql", "completed", "CodeQL SARIF ìƒì„± ì™„ë£Œ", 65)
                }
            }
        }

        stage('Start Serena MCP Server (Discovery)') {
            when {
                anyOf {
                    expression { env.SCAN_MODE == 'custom' }
                    expression { env.SCAN_MODE == 'preset' }
                }
            }
            steps {
                script {
                    reportProgress("mcp", "running", "MCP ì„œë²„ ì‹œì‘", 70)
                    sh """
                        set -e
                        cd $SCANNER_DIR
                        if [ ! -d venv ]; then
                            python3 -m venv venv
                        fi
                        . venv/bin/activate

                        pip install uv
                        nohup uvx --from git+https://github.com/oraios/serena serena start-mcp-server --project "${PROJECT_PATH}" --transport streamable-http --port 9121 &

                        # MCP ì„œë²„ ì‹œì‘

                        # ì„œë²„ ì¤€ë¹„ ëŒ€ê¸°
                        sleep 10
                        
                        # ì„œë²„ê°€ ì‹¤í–‰ ì¤‘ì¸ì§€ í™•ì¸
                        if ps -aux | grep -q serena; then
                            echo "âœ“ MCP ì„œë²„ ì‹œì‘ ì™„ë£Œ"
                        else
                            echo "âš  MCP ì„œë²„ ì»¨í…Œì´ë„ˆê°€ ì‹œì‘ë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤."
                        fi
                """
                    reportProgress("mcp", "completed", "MCP ì„œë²„ ì‹œì‘ ì™„ë£Œ", 75)
                }
            }
        }

        stage('Start Code Indexer Server (Verifier)') {
            when {
                expression { env.SCAN_MODE == 'preset' || env.SCAN_MODE == 'custom'}
            }
            steps {
                script {
                    reportProgress("mcp", "running", "Code Indexer MCP ì„œë²„ ì‹œì‘", 75)
                    sh """
                        set -e
                        apt-get update
                        apt-get install -y lsof
                        apt-get install -y universal-ctags ripgrep
                        
                        cd ${QUICK_SCAN_DIR}/mcp_server
                        if [ ! -d venv ]; then
                            python3 -m venv venv
                        fi
                        . venv/bin/activate
                        pip install -r requirements.txt --quiet

                        cat > .env << EOF
REPO_ROOT=${PROJECT_PATH}
HOST=0.0.0.0
PORT=8000
DEFAULT_MAX_RESULTS=50
MAX_BYTES=8192
DEFAULT_BEFORE=40
DEFAULT_AFTER=40
MAX_BEFORE=120
MAX_AFTER=120
USE_TREE_SITTER=false
ALLOWED_EXTS=".py,.js,.jsx,.mjs,.ts,.tsx,.java,.kt,.kts,.md,.txt"
EOF

                        nohup python3 server.py >/tmp/code-index-mcp.log 2>&1 &
                        sleep 7
                        if lsof | grep 8000; then
                            echo "âœ“ Code Indexer MCP ì„œë²„ ì‹œì‘ ì™„ë£Œ (http://localhost:8000/mcp)"
                        else
                            echo "âš  Code Indexer MCP ì„œë²„ê°€ ì‹œì‘ë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤."
                        fi
                    """
                    reportProgress("mcp", "completed", "Code Indexer MCP ì„œë²„ ì‹œì‘ ì™„ë£Œ", 77)
                }
            }
        }

        stage('Run Source Extractor') {
            when { expression { env.SCAN_MODE == 'custom' && params.RUN_SAST } }
            agent {
                docker {
                    image 'returntocorp/semgrep'
                }
            }
            steps {
                script {
                    sh '''
                        set -e

                        echo "PROJECT_PATH = ${PROJECT_PATH}"
                        ls -la "${PROJECT_PATH}" || echo "PROJECT_PATH not found?"

                        # Semgrep Docker ì´ë¯¸ì§€ ì•ˆì— ê¸°ë³¸ìœ¼ë¡œ ìˆëŠ” /src ë¹„ìš°ê³ 
                        rm -rf /src

                        # /src -> ì‹¤ì œ í”„ë¡œì íŠ¸ ë””ë ‰í† ë¦¬ ë¡œ symlink ìƒì„±
                        ln -s "${PROJECT_PATH}" /src
                        ln -s "${SCANNER_DIR}"/semgrep-rules /semgrep-rules
                        cd ${PROJECT_PATH}
                        semgrep scan --config "/semgrep-rules/" --sarif --sarif-output source-extract.sarif || true
                    '''
                    reportProgress("setup", "completed", "Semgrep ì†ŒìŠ¤ ì¶”ì¶œ ì™„ë£Œ", 78)
                }
            }
        }


        stage('Run Security Analysis') {
            steps {
                script {
                    reportProgress("analysis", "running", "ë³´ì•ˆ ë¶„ì„ ì‹¤í–‰", 80)
                    // ì˜µì…˜: ì»¤ìŠ¤í…€ LLM ì—”ë“œí¬ì¸íŠ¸/í‚¤ë¥¼ í™˜ê²½ë³€ìˆ˜ë¡œ ë…¸ì¶œ (main.pyëŠ” env ê¸°ë°˜ ì„¤ì •)
                    def llmEnvExports = ""
                    def maskPairs = []
                    if (params.LLM_ENDPOINT_URL?.trim()) {
                        llmEnvExports += "export OPENAI_COMPATIBLE_BASE_URL='${params.LLM_ENDPOINT_URL.trim()}'\n"
                        maskPairs << [var: 'LLM_ENDPOINT_URL', password: params.LLM_ENDPOINT_URL.trim()]
                    }
                    if (params.LLM_API_KEY?.trim()) {
                        llmEnvExports += "export OPENAI_API_KEY='${params.LLM_API_KEY.trim()}'\n"
                        llmEnvExports += "export OPENAI_COMPATIBLE_API_KEY='${params.LLM_API_KEY.trim()}'\n"
                        maskPairs << [var: 'LLM_API_KEY', password: params.LLM_API_KEY.trim()]
                    }

                    def runMasked = { cmd ->
                        if (maskPairs) {
                            try {
                                wrap([$class: 'MaskPasswordsBuildWrapper', varPasswordPairs: maskPairs]) {
                                    sh cmd
                                }
                            } catch (ignored) {
                                // í”ŒëŸ¬ê·¸ì¸ ë¯¸ì„¤ì¹˜ ë“±ìœ¼ë¡œ ì‹¤íŒ¨ ì‹œ ë§ˆìŠ¤í‚¹ ì—†ì´ ì‹¤í–‰
                                sh cmd
                            }
                        } else {
                            sh cmd
                        }
                    }



                    if (env.SCAN_MODE == 'preset' || env.SCAN_MODE == 'quick') {
                        // Quick Scan with langgraph-scan
                        runMasked('''
                            set -e
                            cd $QUICK_SCAN_DIR
                            . venv/bin/activate
                            export BUILD_NUMBER=$BUILD_NUMBER
                            export SCAN_TYPE=$SCAN_TYPE
                            export API_BASE_URL=${env.API_BASE ?: params.API_BASE}
''' + llmEnvExports + '''

                            if [ -z "${SEED_FILE_PATH}" ]; then
                                echo "SEED_FILE_PATH is required for quick scan (verifier)."
                                exit 1
                            fi

                            python3 main.py --project $PROJECT_NAME --input-seed-file "${SEED_FILE_PATH}" --provider $API_PROVIDER --model "$MODEL" --no-langsmith
                        ''')
                    } else if (env.SCAN_MODE == 'custom') {
                        // Full Scan: ìˆœì°¨ ì‹¤í–‰ (ë©”ëª¨ë¦¬ ì•ˆì •ì„± ë° ì—ëŸ¬ ì¶”ì  ìš©ì´)
                        
                        // 1. Verifier ì‹¤í–‰ (langgraph-scan)
                        echo "--- [Phase 1] Verifier (Quick Scan) ---"
                        runMasked("""#!/bin/bash
                            set -e
                            cd ${env.QUICK_SCAN_DIR}
                            . venv/bin/activate
                            export BUILD_NUMBER=${env.BUILD_NUMBER}
                            export SCAN_TYPE=${env.SCAN_TYPE}
                            export API_BASE_URL=${env.API_BASE ?: params.API_BASE}
                            export API_PROVIDER=${env.API_PROVIDER ?: params.API_PROVIDER}
                            export MODEL="${env.MODEL ?: params.MODEL}"
${llmEnvExports}
                            if [ -z "${env.SEED_FILE_PATH}" ]; then
                                echo "SEED_FILE_PATH is required for quick scan (verifier)."
                                exit 1
                            fi

                            python3 main.py --project ${env.PROJECT_NAME} --input-seed-file "${env.SEED_FILE_PATH}" --provider \${API_PROVIDER} --model "\${MODEL}" --no-langsmith
                        """.stripIndent())

                        // 2. Discovery ì‹¤í–‰ (langgraph-scanner)
                        echo "--- [Phase 2] Discovery (Deep Analysis) ---"
                        runMasked("""#!/bin/bash
                            set -e
                            cd ${env.SCANNER_DIR}
                            . venv/bin/activate
                            export BUILD_NUMBER=${env.BUILD_NUMBER}
                            export SCAN_TYPE=${env.SCAN_TYPE}
                            export API_BASE_URL=${env.API_BASE ?: params.API_BASE}
                            export API_PROVIDER=${env.API_PROVIDER ?: params.API_PROVIDER}
                            export MODEL="${env.MODEL ?: params.MODEL}"
${llmEnvExports}
                            currentTimeStrfTime=\$(date +"%Y%m%d_%H%M%S")
                            
                            # SARIF íŒŒì¼ì´ ìˆìœ¼ë©´ ë³€í™˜, ì—†ìœ¼ë©´ ë¹ˆ JSON ìƒì„± ë°©ì§€ ë¡œì§ í•„ìš”
                            if [ -f "${env.PROJECT_PATH}/source-extract.sarif" ]; then
                                python3 extract_candidate_from_sarif.py "${env.PROJECT_PATH}/source-extract.sarif" "source-extract_\${currentTimeStrfTime}.json"
                                rm "${env.PROJECT_PATH}/source-extract.sarif"
                                SEED_ARG="--input-seed-file source-extract_\${currentTimeStrfTime}.json"
                            else
                                echo "Source extract SARIF not found, running without seed."
                                SEED_ARG=""
                            fi

                            # ì´ì „ ê²°ê³¼ ì‚­ì œ
                            rm -f analysis_results/${env.PROJECT_NAME}_*.json
                            rm -f discovery_results/${env.PROJECT_NAME}_*.json

                            # API_PROVIDER, MODEL ë“±ì€ ìœ„ì—ì„œ export í–ˆìœ¼ë¯€ë¡œ í™˜ê²½ë³€ìˆ˜ë¡œ ì‚¬ìš©ë¨ (ìŠ¤í¬ë¦½íŠ¸ ë‚´ ì‚¬ìš© ì‹œ \${VAR}ë¡œ ì‰˜ ë³€ìˆ˜ì„ì„ ëª…ì‹œí•˜ê±°ë‚˜ ê·¸ëƒ¥ ì¨ë„ ë¨, ì—¬ê¸°ì„  \$ ì‚¬ìš©)
                            python3 main.py --project ${env.PROJECT_NAME} --mode full --provider \${API_PROVIDER} --model "\${MODEL}" --use-env --ignore-previous-versions --input-seed-source json \$SEED_ARG --no-langsmith
                        """.stripIndent())
                    }
                    reportProgress("analysis", "completed", "ë³´ì•ˆ ë¶„ì„ ì™„ë£Œ", 85)
                }
            }
        }

        stage('Callback Ingest') {
            steps {
                script {
                    reportProgress("upload", "running", "ê²°ê³¼ ì „ì†¡", 90)
                    def discoveryResultFile = "${env.SCANNER_DIR}/analysis_results/${env.PROJECT_NAME}_latest.json"
                    def verifierResultFile  = "${env.QUICK_SCAN_DIR}/results/${env.PROJECT_NAME}_report_latest.json"

                    sh """
                        set -e
                        export SCAN_MODE="${env.SCAN_MODE}"
                        export DISCOVERY_RESULT_FILE="${discoveryResultFile}"
                        export VERIFIER_RESULT_FILE="${verifierResultFile}"
                        export API_PROVIDER="${params.API_PROVIDER}"
                        export MODEL="${params.MODEL}"
                        export SCAN_TYPE="${env.SCAN_TYPE}"
                        export BUILD_NUMBER="${BUILD_NUMBER}"

                        # ê²°ê³¼ JSONì„ IngestScanResults ìŠ¤í‚¤ë§ˆì— ë§ê²Œ ë˜í•‘
                        python3 - <<'PY'
import json
import os
import sys
from pathlib import Path

scan_mode = os.environ.get("SCAN_MODE", "")
candidate_files = []
if scan_mode == "preset":
    candidate_files.append(os.environ.get("VERIFIER_RESULT_FILE"))
else:
    candidate_files.extend([
        os.environ.get("DISCOVERY_RESULT_FILE"),
        os.environ.get("VERIFIER_RESULT_FILE"),
    ])

existing_files = [p for p in candidate_files if p and os.path.isfile(p)]
if not existing_files:
    print(f"âš  ê²°ê³¼ íŒŒì¼ì„ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤: {candidate_files}")
    sys.exit(1)

def extract_vulns(data):
    if isinstance(data, list):
        return data
    if isinstance(data, dict):
        if isinstance(data.get("vulnerabilities"), list):
            return data["vulnerabilities"]
        structured = data.get("structured_result")
        if isinstance(structured, dict) and isinstance(structured.get("vulnerabilities"), list):
            return structured["vulnerabilities"]
        return [data]
    return []

all_vulns = []
for path in existing_files:
    try:
        with open(path, "r", encoding="utf-8") as fh:
            data = json.load(fh)
        all_vulns.extend(extract_vulns(data))
    except Exception as exc:
        print(f"âš  ê²°ê³¼ íŒŒì¼ ë¡œë“œ ì‹¤íŒ¨ ({path}): {exc}")

if not all_vulns:
    print("âš  ì·¨ì•½ì  ë°ì´í„°ë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.")
    sys.exit(1)

payload = {
    "provider": os.environ.get("API_PROVIDER"),
    "model": os.environ.get("MODEL"),
    "scan_type": os.environ.get("SCAN_TYPE"),
    "build_number": os.environ.get("BUILD_NUMBER"),
    "vulnerabilities": all_vulns,
    "vulnerability_count": len(all_vulns),
}

payload.setdefault("status", "completed")

Path("ingest_payload.json").write_text(json.dumps(payload), encoding="utf-8")
print(f"âœ“ ë³‘í•©ëœ ì·¨ì•½ì  {len(all_vulns)}ê±´, ì‚¬ìš©ëœ íŒŒì¼: {', '.join(existing_files)}")
PY
                        
                        # ë°±ì—”ë“œë¡œ ê²°ê³¼ ì „ì†¡
                        curl -X POST "${env.API_BASE ?: params.API_BASE}/projects/${env.PROJECT_ID ?: params.PROJECT_ID}/scans/${env.SCAN_ID ?: params.SCAN_ID}/ingest" \\
                            -H "Content-Type: application/json" \\
                            -H "X-Api-Key: ${env.BACKEND_SERVICE_API_KEY}" \\
                            -H "X-Jenkins-Token: ${env.JENKINS_CALLBACK_SECRET}" \\
                            -d @ingest_payload.json
                        
                        echo "âœ“ ê²°ê³¼ ì „ì†¡ ì™„ë£Œ"
                    """
                    reportProgress("upload", "completed", "ê²°ê³¼ ì „ì†¡ ì™„ë£Œ", 95)
                }
            }
        }

        stage('Archive Results') {
            steps {
                script {
                    reportProgress("retrieve", "running", "ê²°ê³¼ ì•„ì¹´ì´ë¹™", 97)
                    def resultDir = env.SCAN_MODE == 'preset' ? env.QUICK_SCAN_DIR : env.SCANNER_DIR
                    def resultFile = env.SCAN_MODE == 'preset' ? 
                        "${resultDir}/results/${env.PROJECT_NAME}_report_latest.json" :
                        "${resultDir}/analysis_results/${env.PROJECT_NAME}_latest.json"

                    sh """
                        set -e
                        # archiveArtifactsëŠ” ì›Œí¬ìŠ¤í˜ì´ìŠ¤ ë‚´ íŒŒì¼ë§Œ ì•„ì¹´ì´ë¸Œ ê°€ëŠ¥í•˜ë¯€ë¡œ ë¡œì»¬ results/ë¡œ ë³µì‚¬
                        mkdir -p results
                        cp ${resultFile} results/${env.PROJECT_NAME}_build${BUILD_NUMBER}.json
                        echo "âœ“ ê²°ê³¼ ì•„ì¹´ì´ë¹™ ì™„ë£Œ"
                    """

                    // ì›Œí¬ìŠ¤í˜ì´ìŠ¤ ë‚´ë¶€ results/ ì•„ë˜ JSON ì•„ì¹´ì´ë¸Œ
                    dir('results') {
                        archiveArtifacts artifacts: "**/*.json", allowEmptyArchive: false
                    }
                    reportProgress("retrieve", "completed", "ê²°ê³¼ ì•„ì¹´ì´ë¹™ ì™„ë£Œ", 100)
                }
            }
        }
    }

    post {
        always {
            script {
                echo "íŒŒì´í”„ë¼ì¸ ì¢…ë£Œ (ë¹Œë“œ #${BUILD_NUMBER})"

                // MCP ì„œë²„ ì •ë¦¬
                sh '''
                    # docker stop serena-mcp 2>/dev/null || true
                    # docker rm serena-mcp 2>/dev/null || true
                '''
            }
        }
        success {
            echo "âœ“ ìŠ¤ìº” ì„±ê³µ"
            script {
                sendEmailNotification("SUCCESS", "")
                reportProgress("retrieve", "completed", "íŒŒì´í”„ë¼ì¸ ì„±ê³µ", 100)
            }
        }
        failure {
            echo "âœ— ìŠ¤ìº” ì‹¤íŒ¨"
            script {
                sendEmailNotification("FAILED", currentBuild?.result ?: "failed")
                reportProgress("retrieve", "failed", "íŒŒì´í”„ë¼ì¸ ì‹¤íŒ¨", 100)
            }
        }
    }
}
